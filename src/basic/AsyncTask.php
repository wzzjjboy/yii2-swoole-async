<?php

namespace yii2\swoole_async\basic;

use Pheanstalk\Job;
use Yii;
use yii\base\BaseObject;
use yii\base\InvalidConfigException;
use yii2\swoole_async\models\DB;
use yii2\swoole_async\models\Mysql;

/**
 *
 */
abstract class AsyncTask extends BaseObject
{
    /**
     * @var int
     */
    public $taskBId;

    /**
     * @var Rule
     */
    public $rule;

    /**
     * @var string
     */
    public $ruleClass = 'yii2\swoole_async\basic\Rule';

    /**
     * @var DB
     */
    public $db = 'yii2\swoole_async\models\Mysql';

    /**
     * @var string
     */
    private $name;

    /**
     * @var array
     */
    public $data;

    /**
     * @var Swoole
     */
    public $swoole = 'swoole';

    /**
     * 订单时间最大值(目前最大只支持1天)
     * @var int
     */
    private $maxInterval = 86400000;

    /**
     * @throws InvalidConfigException
     * @throws TaskException
     */
    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        if (empty($this->rule)){
            self::showError("未配置rule参数!");
        } elseif (!is_object($this->rule)){
            if (!isset($this->rule['class'])){
                $this->rule['class']  = $this->ruleClass;
            }
            $this->rule = Yii::createObject($this->rule);
            if (!$this->rule->validate()){
                self::showError(current($this->rule->getFirstErrors()));
            }
        }
        $this->name = $this->getTaskName();
        $this->swoole = Yii::$app->get("swoole");
    }


    /**
     * 查询任务
     * @param string $taskBId
     * @param string $taskName
     * @return AsyncTask
     * @throws TaskException
     */
    public static function findTask(string $taskBId, string $taskName):AsyncTask
    {
        $model = Mysql::findTask($taskBId, $taskName);
        if (empty($model)){
            self::showError("不存在的任务:{$taskBId}-{$taskName}");
        }
        return self::loadTask($model);
    }

    /**
     * 加载未完成的任务
     * @param Mysql $model
     * @return static
     */
    private static function loadTask(Mysql $model): AsyncTask
    {
        $cnf = [
            'class' => $model->getTaskClass(),
            'taskBId' => $model->getTaskBId(),
            'data' => json_decode($model->getData(), true),
            'rule' => Yii::createObject(json_decode($model->getRule(), true)),
            'db' => $model,
        ];
        $task = Yii::createObject($cnf);

        return $task;
    }

    /**
     * @return AsyncTask[]
     */
    public static function findAllForLoading()
    {
        $all = [];
        $list = Mysql::findAllForLoading();
        foreach ($list as $item){
            $all[] = self::loadTask($item);
        }
        return $all;
    }

    /**
     * 消费任务
     * @param mixed $data
     * @return bool
     */
    public abstract function consume($data):bool;

    /**
     * 任务标识为已完成
     * @return void
     */
    private function taskFinished(): void
    {
        // TODO: implement here
        $this->db->taskFinished();
    }

    /**
     * 任务标识为需要继续执行
     * @return bool
     */
    public function taskContinue():bool
    {
        // TODO: implement here
        return $this->db->taskContinue();
    }

    /**
     * 获取任务名
     * @return string
     */
    public function getTaskName():string
    {
        if (!$this->name){
            $this->name = lcfirst((new \ReflectionClass($this))->getShortName());
        }

        return $this->name;
    }

    /**
     * 获取任务运行次数
     * @return int
     */
    public function getTaskRunCount():int
    {
        // TODO: implement here
        return $this->db->getRunCount();
    }

    /**
     * 抛出异常
     * @param $msg
     * @throws TaskException
     */
    public static function showError($msg)
    {
        throw new TaskException($msg);
    }

    /**
     * 生成任务数据
     * @param array $data
     * @return static
     * @throws TaskException
     * @throws InvalidConfigException
     */
    public static function generate(string $taskBId, array $data, $repeat = false): AsyncTask
    {
        if (!is_array($data)){
            self::showError("data参数必须是数组");
        }

        if (isset($data['taskId'])){
            self::showError("不允许配置task id");
        }

        $cnf = [
            'class' => get_called_class(),
            'data' => $data,
        ];

        /** @var static $task */
        $task = Yii::createObject($cnf);

        $config = [
            'task_class' => $cnf['class'],
            'task_name' => $task->getTaskName(),
            'task_data' => $task->toStr($task->data),
            'task_rule' => $task->rule->toJson(),
            'task_b_id'  => $taskBId,
            'task_type' => $task->rule->getTypeNum(),
        ];

        if ($repeat){
            $config['task_b_id'] = $config['task_b_id'] ."|" . time();
        }

        if (Mysql::findTask($config['task_b_id'], $task->getTaskName())){
            throw new TaskException("任务：{$taskBId}已经存在...");
        }

        if(!($model = $task->db::generate($config, $msg))){
            self::showError($msg);
        }

        $task->taskBId = $model->getTaskBId();
        $task->db = $model;

        return $task;
    }

    /**
     * 标识任务已完成
     * @return  bool
     */
    public function taskIsFinish(): bool
    {
        return $this->db->isFinish();
    }

    /**
     * 转json
     * @param $mixed
     * @return string
     */
    private function toStr($mixed): string
    {
        return is_array($mixed) ? json_encode($mixed, JSON_UNESCAPED_UNICODE) : $mixed;
    }

    /**
     * 任务标记为已超出最大运行次数（不会再执行）
     * @return bool
     */
    public function taskOver(): bool
    {
        $this->beforeTaskOver($this->data);
        $res =  $this->db->taskOver();
        $this->afterTaskOver($this->data);
        return $res;
    }

    /**
     * 查询任务标是否已超出最大运行次数
     * @return bool
     */
    public function taskIsOver(): bool
    {
        return $this->db->isOver();
    }


    /**
     * 计算任务下次运行的间隔
     * @return array
     * @throws TaskException
     */
    public function getInterval(): array
    {
        if ($this->taskIsFinish() || $this->taskIsOver()){
            return [false, false];
        }

        if($this->rule->isAsync()){
            return[2000/1000, false];
        }

        list($firstInterval, $nextInterval) = $this->rule->getInterval($this);

        if ($firstInterval === false){
            return [false, false];
        }

        if ($firstInterval > $this->maxInterval || $nextInterval > $this->maxInterval){
            self::showError("延迟任务最长时间不能超过1天");
        }

        if ($this->rule->isDelay()){
            if ($firstInterval < 3000){ //解决数据库查询不到任务的问题
                $firstInterval = 3000;
            }

            return [$firstInterval/1000, false];
        }

        if ($this->rule->isTimed()){
            if ($nextInterval){
                return [$firstInterval/1000, $nextInterval/1000];
            } else {
                return [$firstInterval/1000, false];
            }
        }

        self::showError("无法解析(任务：$this->taskBId)定时器时间间隔!");
    }

    /**
     * 执行任务
     * @return bool
     * @throws \Exception
     */
    public function run(): bool
    {
        if ($this->taskIsFinish() || $this->taskIsOver()){
            return true;
        }
        try{
            $result = $this->consume($this->data);
            $this->taskLogic($result);
            return $result;
        }catch (\Exception $exception){
            $this->taskLogic(false);
            throw $exception;
        }
    }

    private function taskLogic($result): void
    {
        if($this->rule->isAsync()){ //异步任务不管执行结果都标记为已完成
            $this->taskFinished();
            return;
        }

        if ($this->rule->isDelay() && true === $result) { //延迟任务只有返回true才标识为已完成
            $this->taskFinished();
        } else {
            $this->taskContinue(); //延迟任务返回false、定时任务都需要继续执行
        }
    }

    /**
     * 任务超出运行前的回调函数
     * @param array $data
     */
    public function beforeTaskOver(array $data)
    {

    }


    /**
     * 任务超出运行后的回调函数
     * @param array $data
     */
    public function afterTaskOver(array $data)
    {

    }

    /**
     * @throws InvalidConfigException
     * @throws TaskException
     */
    public static function publish(string $taskBId, $data = [])
    {
        /** @var Swoole $swoole */
        $swoole = Yii::$app->get("swoole");
        $swoole->publish(self::generate($taskBId, $data));
    }

    public function getJob(): Job
    {
        return new Job($this->db->job_id, AsyncJob::getPutData($this));
    }

    public function saveJobId(int $jobId):bool
    {
        return $this->db->saveJob($jobId);
    }
}
