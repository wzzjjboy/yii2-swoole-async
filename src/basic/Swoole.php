<?php

namespace yii2\swoole_async\basic;

use Pheanstalk\Job;
use Pheanstalk\Pheanstalk;
use Swoole\Process;
use Swoole\Process\Pool;
use Yii;
use yii\base\Component;
use yii\base\NotSupportedException;
use yii2\mq_task\basic\ITask;

/**
 *
 */
class Swoole extends Component implements IEngine
{
    use ResponseTrait;
    /**
     * task进程启动事件
     */
    const EVENT_START = 'ent_swoole_on_start';

    /**
     * task work进程开始处理事件
     */
    const EVENT_WORK_ON_TASK = 'ent_swoole_on_task';

    const TAB_WORK_ID = "work_id";

    const TAB_RUN_COUNT = "run_cont";

    const TAB_WORK_PID = 'work_pid';

    /**
     * @var swoole_server
     */
    private $server;

    /**
     * @var ILog
     */
    public $log = 'yii2\swoole_async\basic\Log';

    /**
     * @var string
     */
    public $host;

    /**
     * @var int
     */
    public $port;

    /**
     * @var int
     */
    private $workerNum = 1;

    /**
     * @var int
     */
    public $taskWorkerNum;

    /**
     * @var bool
     */
    public $daemonize;

    /**
     * @var integer
     */
    public $pid;

    /**
     * @var Table
     */
    private $tab;

    /**
     * @var integer
     */
    public $maxRunCount = 10000;


    /**
     * @var AsyncTask
     */
    public $taskClass = 'yii2\swoole_async\basic\AsyncTask';
    /**
     * @var mixed
     */
    public $tube = 'default';
    /**
     * @var mixed|Pheanstalk
     */
    private $pheanstalk;
    /**
     * @var string
     */
    private $pidName = 'asyncTask';

    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        if (empty($this->log)) {
            $this->log = [
                'class' => Log::class,
            ];
        }
        if (is_array($this->log)) {
            $this->log = Yii::createObject($this->log);
        }
        if (!$this->log instanceof ILog) {
            $this->InvalidArgument("无效的log配置");
        }
    }

    /**
     * @param AsyncTask $task
     * @return bool
     */
    public function publish(AsyncTask $task)
    {

    }

    /**
     *
     */
    public function loadingTask():void
    {
        // TODO: implement here
        $i = 0;
        $this->log->trace("loading tasks... ");
        ini_set('memory_limit', '256M');
        try{
            foreach ($this->taskClass::findAllForLoading() as $task)
            {
                $i++;
                $this->publish($task);
                if(0 == $i % 20){
                    //sleep(2);禁用sleep
                }
            }
            $this->log->trace("load tasks finish ");
        }catch (TaskException $exception) {
            $this->handlerTaskException($exception);
        }catch (\Exception $e){
            $this->handlerException($e);
        }
    }

    /**
     * @inheritDoc
     */
    public function start():void
    {
        if (($pid = $this->isRunning())) {
            $this->Running($pid);
            return;
        }
        $pool = new Pool($this->workerNum);
        $pool->on("WorkerStart", function (Pool $pool, $workerId) {
            $running = true;
            /** @var Process $process */
            $process = $pool->getProcess($workerId);
            $this->log->info("onWorkerStart: workerId:{$workerId}  pid:{$process->pid}");
            $this->savePid(posix_getppid());
            $this->pheanstalk = $pheanstalk = Pheanstalk::create($this->host);
            pcntl_signal(SIGTERM, function () use (&$running, $process) {
                $running = false;
                $this->log->info("pid:{$process->pid} 收到SIGTERM信号，准备退出...");
            });
            while ($running) {
                $free = false;
                /** @var ITask $task */
                $job = $pheanstalk->watch($this->tube)->reserveWithTimeout(2);
                $this->onTask($job);
                pcntl_signal_dispatch();
                if ($free === true){
                    Process::kill($process->pid, SIGTERM);
                }
            }
        });
        $pool->start();
    }

    public function onReceive(Pheanstalk $pheanstalk, ?Job $job): bool
    {
        $taskId = $job->getData();
        $this->log->trace("onReceive taskId:{$taskId}");
        try{
            $task = $this->taskClass::findById($taskId);
            list($first, $next) = $task->getInterval();
            if (false === $first){
                $task->taskOver();
                $this->log->trace("task : ($task->taskId) has over " );
                return false;
            }
            $this->intervalLog($task, $first, $next);
            $pheanstalk->put($job->getData(), 1024, $next);
        }catch (TaskException $exception) {
            $this->pheanstalk->bury($job);
            $this->handlerTaskException($exception);
        }catch (\Exception $e){
            $this->handlerException($e);
            $this->pheanstalk->bury($job);
        }
    }

    /**
     * @param AsyncTask $task
     * @param integer|false $first
     * @param null|integer|false $next
     */
    private function intervalLog($task, $first, $next = null)
    {
        if ($task->rule->isTimed()){
            $msg = "calc timed task($task->taskId) interval, first: $first, next: $next";
        } else {
            $taskType = $task->rule->isDelay() ? "delay" : "async";
            $msg = "calc {$taskType} task({$task->taskId}) interval: $first";
        }
        $this->log->trace($msg);
    }


    public function onWorkerStart(swoole_server $server, int $worker_id)
    {
        if (!$server->taskworker){
            $this->log->trace("work start  \tid: {$worker_id} \tpid: {$server->worker_pid}");
            $this->loadingTask();
            $this->trigger(self::EVENT_START);
        } else {
            $this->log->trace("task work start \tid: {$worker_id} \tpid: {$server->worker_pid}");
        }
    }


    public function onTask(Job $job): bool
    {
        $taskId = $job->getData();
        $this->log->trace(["on task" => $taskId]);
        try{
            $task = $this->taskClass::findById($taskId);
            $task->run();
            return $this->onFinish($task, $job);
        }catch (\Exception $e){
            $this->handlerException($e);
            $this->pheanstalk->bury($job);
            return false;
        }
    }

    public function onFinish(AsyncTask $task, Job $job): bool
    {
        $this->log->trace("work: {$task->taskId} on finish}");
        try{
            $this->log->info([
                'task_id' => $task->taskId,
                'taskIsFinish' => $task->taskIsFinish(),
                'taskIsOver' => $task->taskIsOver(),
            ]);
            if ($task->taskIsFinish()){
                $this->log->trace("task : ($task->taskId) has finished " );
                return true;
            }
            list($interval) = $task->getInterval();
            $this->intervalLog($task, $interval);

            if ($interval){
                $this->pheanstalk->put($task->forPut(), 1024, $interval, 60);
            } elseif (false === $interval){
                $task->taskOver();
                $this->log->trace("task : ($task->taskId) has over " );
            }
        }catch (TaskException $exception) {
            $this->handlerTaskException($exception);
            $this->pheanstalk->bury($job);
        }catch (\Exception $e){
            $this->handlerException($e);
            $this->pheanstalk->bury($job);
        }
    }

    /**
     * @inheritDoc
     */
    public function stop():void
    {
        if (!($pid = $this->getPid())) {
            $this->Term();
            return;
        }
        Process::kill($pid, SIGTERM);
    }

    /**
     * @inheritDoc
     */
    public function status():void
    {
        if (!($pid = $this->isRunning())) {
            $this->Term();
            return;
        }
        echo sprintf("MqTask正在运行：%s。。。\n", $pid);
    }

    /**
     *@inheritDoc
     */
    public function reload(): void
    {
        if (!($pid = $this->getPid())) {
            $this->Term();
            return;
        }
        Process::kill($pid, SIGUSR1);
    }

    /**
     * @throws NotSupportedException
     */
    public function restart():void
    {
        throw new NotSupportedException();
    }

    /**
     * @return int
     */
    private function isRunning(): int
    {
        if (!($pid = $this->getPid()) || (!Process::kill($pid, 0))) {
            return 0;
        }
        return $pid;
    }

    /**
     * @param $pid
     */
    private function savePid($pid)
    {
        file_put_contents($this->getPidFile(), $pid);
    }

    /**
     * @return int
     */
    private function getPid(): int
    {
        if (!file_exists($this->getPidFile())) {
            return 0;
        }
        return intval(file_get_contents($this->getPidFile()));
    }

    /**
     * @return string
     */
    private function getPidFile(): string
    {
        return Yii::$app->getRuntimePath() . DIRECTORY_SEPARATOR . $this->pidName .'.pid';
    }

    /**
     * @param TaskException $taskException
     */
    public function handlerTaskException(TaskException $taskException)
    {
        $this->log->warning(implode(PHP_EOL, [
            $taskException->getName(),
            $taskException->getMessage(),
            $taskException->getFile(),
            $taskException->getLine(),
            $taskException->getTraceAsString(),
        ]));
    }

    /**
     * @param \Exception $exception
     */
    public function handlerException(\Exception $exception)
    {
        $this->log->error(implode(PHP_EOL, [
            $exception->getMessage(),
            $exception->getLine(),
            $exception->getFile(),
            $exception->getTraceAsString(),
        ]));
    }
}
